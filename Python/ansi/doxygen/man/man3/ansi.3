.TH "ansi" 3 "Sat Jan 22 2022" "Version 1.0" "ANSI-Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ansi
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "def \fBSGR\fP (str)"
.br
.RI "Sets colors and style of the characters following this code Example: \fBansi\&.SGR\fP('4091') makes RED_HI over BK_BLACK\&. "
.ti -1c
.RI "def \fBRGB\fP (r, g, b)"
.br
.RI "Specify the Foreground color in RGB\&. "
.ti -1c
.RI "def \fBBK_RGB\fP (r, g, b)"
.br
.RI "Specify the Background color in RGB\&. "
.ti -1c
.RI "def \fBCUU\fP (n)"
.br
.RI "Moves the cursor n (default 1) cells up\&. "
.ti -1c
.RI "def \fBCUD\fP (n)"
.br
.RI "Moves the cursor n (default 1) cells down\&. "
.ti -1c
.RI "def \fBCUF\fP (n)"
.br
.RI "Moves the cursor n (default 1) cells forwards\&. "
.ti -1c
.RI "def \fBCUB\fP (n)"
.br
.RI "Moves the cursor n (default 1) cells backwards\&. "
.ti -1c
.RI "def \fBCNL\fP (n)"
.br
.RI "Moves cursor to beginning of the line n (default 1) lines down\&. "
.ti -1c
.RI "def \fBCPL\fP (n)"
.br
.RI "Moves cursor to beginning of the line n (default 1) lines up\&. "
.ti -1c
.RI "def \fBCHA\fP (n)"
.br
.RI "Moves the cursor to column n (default 1) "
.ti -1c
.RI "def \fBCUP\fP (row, col)"
.br
.RI "Moves the cursor to [row, column]\&. "
.ti -1c
.RI "def \fBED\fP (n)"
.br
.RI "Clears part of the screen\&. "
.ti -1c
.RI "def \fBEL\fP (n)"
.br
.RI "Erases part of the line If n is 0 (or missing), clear from cursor to the end of the line If n is 1, clear from cursor to beginning of the line If n is 2, clear entire line\&. "
.ti -1c
.RI "def \fBSU\fP (n)"
.br
.RI "Scroll whole page up by n (default 1) lines\&. "
.ti -1c
.RI "def \fBSD\fP (n)"
.br
.RI "Scroll whole page down by n (default 1) lines\&. "
.ti -1c
.RI "def \fBHVP\fP (row, col)"
.br
.RI "Same as CUP, but counts as a format effector function (like CR or LF) rather than an editor function (like CUD or CNL) This can lead to different handling in certain terminal modes\&. "
.ti -1c
.RI "def \fBcustom\fP (str)"
.br
.RI "Returns a custom ANSI ESCAPE SEQUENCE\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "string \fBESC\fP = '\\u001B'"
.br
.ti -1c
.RI "string \fBCSI\fP = '\\u009B'"
.br
.ti -1c
.RI "string \fBDSC\fP = '\\u0090'"
.br
.ti -1c
.RI "string \fBOSC\fP = '\\u009D'"
.br
.ti -1c
.RI "string \fBRESET\fP = \fBESC\fP+'[0m'"
.br
.ti -1c
.RI "string \fBBOLD\fP = \fBESC\fP+'[1m'"
.br
.ti -1c
.RI "string \fBFAINT\fP = \fBESC\fP+'[2m'"
.br
.ti -1c
.RI "string \fBITALIC\fP = \fBESC\fP+'[3m'"
.br
.ti -1c
.RI "string \fBUNDER\fP = \fBESC\fP+'[4m'"
.br
.ti -1c
.RI "string \fBSBLINK\fP = \fBESC\fP+'[5m'"
.br
.ti -1c
.RI "string \fBRBLINK\fP = \fBESC\fP+'[6m'"
.br
.ti -1c
.RI "string \fBREVERSE\fP = \fBESC\fP+'[7m'"
.br
.ti -1c
.RI "string \fBHIDE\fP = \fBESC\fP+'[8m'"
.br
.ti -1c
.RI "string \fBSTRIKE\fP = \fBESC\fP+'[9m'"
.br
.ti -1c
.RI "string \fBDEF_FONT\fP = \fBESC\fP+'[10m'"
.br
.RI "Default font\&. "
.ti -1c
.RI "string \fBFranktur\fP = \fBESC\fP+'[20m'"
.br
.RI "Rarely supported font\&. "
.ti -1c
.RI "string \fBBOLD_OFF\fP = \fBESC\fP+'[21m'"
.br
.ti -1c
.RI "string \fBHI_OFF\fP = \fBESC\fP+'[22m'"
.br
.ti -1c
.RI "string \fBITALIC_OFF\fP = \fBESC\fP+'[23m'"
.br
.ti -1c
.RI "string \fBUNDER_OFF\fP = \fBESC\fP+'[24m'"
.br
.ti -1c
.RI "string \fBBLINK_OFF\fP = \fBESC\fP+'[25m'"
.br
.ti -1c
.RI "string \fBREVERSE_OFF\fP = \fBESC\fP+'[27m'"
.br
.ti -1c
.RI "string \fBREVEAL\fP = \fBESC\fP+'[28m'"
.br
.ti -1c
.RI "string \fBSTRIKE_OFF\fP = \fBESC\fP+'[29m'"
.br
.ti -1c
.RI "string \fBBLACK\fP = \fBESC\fP+'[30m'"
.br
.ti -1c
.RI "string \fBRED\fP = \fBESC\fP+'[31m'"
.br
.ti -1c
.RI "string \fBGREEN\fP = \fBESC\fP+'[32m'"
.br
.ti -1c
.RI "string \fBYELLOW\fP = \fBESC\fP+'[33m'"
.br
.ti -1c
.RI "string \fBBLUE\fP = \fBESC\fP+'[34m'"
.br
.ti -1c
.RI "string \fBPURPLE\fP = \fBESC\fP+'[35m'"
.br
.ti -1c
.RI "string \fBCYAN\fP = \fBESC\fP+'[36m'"
.br
.ti -1c
.RI "string \fBWHITE\fP = \fBESC\fP+'[37m'"
.br
.ti -1c
.RI "string \fBDEFAULT\fP = \fBESC\fP+'[39m'"
.br
.ti -1c
.RI "string \fBBK_BLACK\fP = \fBESC\fP+'[40m'"
.br
.ti -1c
.RI "string \fBBK_RED\fP = \fBESC\fP+'[41m'"
.br
.ti -1c
.RI "string \fBBK_GREEN\fP = \fBESC\fP+'[42m'"
.br
.ti -1c
.RI "string \fBBK_YELLOW\fP = \fBESC\fP+'[43m'"
.br
.ti -1c
.RI "string \fBBK_BLUE\fP = \fBESC\fP+'[44m'"
.br
.ti -1c
.RI "string \fBBK_PURPLE\fP = \fBESC\fP+'[45m'"
.br
.ti -1c
.RI "string \fBBK_CYAN\fP = \fBESC\fP+'[46m'"
.br
.ti -1c
.RI "string \fBBK_WHITE\fP = \fBESC\fP+'[47m'"
.br
.ti -1c
.RI "string \fBBK_DEFAULT\fP = \fBESC\fP+'[49m'"
.br
.ti -1c
.RI "string \fBBLACK_HI\fP = \fBESC\fP+'[90m'"
.br
.ti -1c
.RI "string \fBRED_HI\fP = \fBESC\fP+'[91m'"
.br
.ti -1c
.RI "string \fBGREEN_HI\fP = \fBESC\fP+'[92m'"
.br
.ti -1c
.RI "string \fBYELLOW_HI\fP = \fBESC\fP+'[93m'"
.br
.ti -1c
.RI "string \fBBLUE_HI\fP = \fBESC\fP+'[94m'"
.br
.ti -1c
.RI "string \fBPURPLE_HI\fP = \fBESC\fP+'[95m'"
.br
.ti -1c
.RI "string \fBCYAN_HI\fP = \fBESC\fP+'[96m'"
.br
.ti -1c
.RI "string \fBWHITE_HI\fP = \fBESC\fP+'[97m'"
.br
.ti -1c
.RI "string \fBBK_BLACK_HI\fP = \fBESC\fP+'[100m'"
.br
.ti -1c
.RI "string \fBBK_RED_HI\fP = \fBESC\fP+'[101m'"
.br
.ti -1c
.RI "string \fBBK_GREEN_HI\fP = \fBESC\fP+'[102m'"
.br
.ti -1c
.RI "string \fBBK_YELLOW_HI\fP = \fBESC\fP+'[103m'"
.br
.ti -1c
.RI "string \fBBK_BLUE_HI\fP = \fBESC\fP+'[104m'"
.br
.ti -1c
.RI "string \fBBK_PURPLE_HI\fP = \fBESC\fP+'[105m'"
.br
.ti -1c
.RI "string \fBBK_CYAN_HI\fP = \fBESC\fP+'[106m'"
.br
.ti -1c
.RI "string \fBBK_WHITE_HI\fP = \fBESC\fP+'[107m'"
.br
.ti -1c
.RI "string \fBC0\fP = \fBESC\fP+'[11H'"
.br
.RI "Place the cursor in top-left corner Same as CUP(1,1) "
.ti -1c
.RI "string \fBCUU1\fP = \fBESC\fP+'[1A'"
.br
.RI "Move the cursor 1 row up\&. "
.ti -1c
.RI "string \fBCUD1\fP = \fBESC\fP+'[1B'"
.br
.RI "Move the cursor 1 row down\&. "
.ti -1c
.RI "string \fBCUF1\fP = \fBESC\fP+'[1C'"
.br
.RI "Move the cursor 1 cell forwards\&. "
.ti -1c
.RI "string \fBCUB1\fP = \fBESC\fP+'[1D'"
.br
.RI "Move the cursor 1 cell backwards\&. "
.ti -1c
.RI "string \fBCNL1\fP = \fBESC\fP+'[1E'"
.br
.RI "Moves cursor to beginning of the next line\&. "
.ti -1c
.RI "string \fBCPL1\fP = \fBESC\fP+'[1F'"
.br
.RI "Moves cursor to beginning of the previous line\&. "
.ti -1c
.RI "string \fBSU1\fP = \fBESC\fP+'[1S'"
.br
.RI "Scroll whole page up by 1 line\&. "
.ti -1c
.RI "string \fBSD1\fP = \fBESC\fP+'[1T'"
.br
.RI "Scroll whole page down by 1 line\&. "
.ti -1c
.RI "string \fBED0\fP = \fBESC\fP+'[0J'"
.br
.RI "Clear from cursor to end of screen\&. "
.ti -1c
.RI "string \fBED1\fP = \fBESC\fP+'[1J'"
.br
.RI "Clear from cursor to beginning of the screen\&. "
.ti -1c
.RI "string \fBED2\fP = \fBESC\fP+'[2J'"
.br
.RI "Clear entire screen (and moves cursor to upper left on DOS ANSI\&.SYS) "
.ti -1c
.RI "string \fBED3\fP = \fBESC\fP+'[3J'"
.br
.RI "Clear entire screen and delete all lines saved in the scrollback buffer (this feature was added for xterm and is supported by other terminal applications) "
.ti -1c
.RI "string \fBEL0\fP = \fBESC\fP+'[0K'"
.br
.RI "Clear from cursor to the end of the line\&. "
.ti -1c
.RI "string \fBEL1\fP = \fBESC\fP+'[1K'"
.br
.RI "Clear from cursor to beginning of the line\&. "
.ti -1c
.RI "string \fBEL2\fP = \fBESC\fP+'[2K'"
.br
.RI "Clear entire line\&. "
.ti -1c
.RI "string \fBAUX_PORT_ON\fP = \fBESC\fP+'[5i'"
.br
.RI "Enable aux serial port usually for local serial printer\&. "
.ti -1c
.RI "string \fBAUX_PORT_OFF\fP = \fBESC\fP+'[4i'"
.br
.RI "Enable aux serial port usually for local serial printer\&. "
.ti -1c
.RI "string \fBDSR\fP = \fBESC\fP+'[6n'"
.br
.RI "Reports the cursor position (CPR) by transmitting ESC[nmR, where n is the row and m is the column\&. "
.ti -1c
.RI "string \fBSCP\fP = \fBESC\fP+'[s'"
.br
.RI "Saves the cursor position/state in SCO console mode In vertical split screen mode, instead used to set (as CSI n n s) or reset left and right margins\&. "
.ti -1c
.RI "string \fBRCP\fP = \fBESC\fP+'[u'"
.br
.RI "Restores the cursor position/state in SCO console mode\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "def ansi\&.BK_RGB ( r,  g,  b)"

.PP
Specify the Background color in RGB\&. 
.PP
\fBParameters\fP
.RS 4
\fIr\fP (int) Red value 
.br
\fIg\fP (int) Green value 
.br
\fIb\fP (int) Blue value 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.CHA ( n)"

.PP
Moves the cursor to column n (default 1) 
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.CNL ( n)"

.PP
Moves cursor to beginning of the line n (default 1) lines down\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.CPL ( n)"

.PP
Moves cursor to beginning of the line n (default 1) lines up\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.CUB ( n)"

.PP
Moves the cursor n (default 1) cells backwards\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.CUD ( n)"

.PP
Moves the cursor n (default 1) cells down\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.CUF ( n)"

.PP
Moves the cursor n (default 1) cells forwards\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.CUP ( row,  col)"

.PP
Moves the cursor to [row, column]\&. The values are 1-based\&.
.PP
\fBParameters\fP
.RS 4
\fIrow\fP (int) 
.br
\fIcol\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.custom ( str)"

.PP
Returns a custom ANSI ESCAPE SEQUENCE\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP (String) 
.RE
.PP
\fBReturns\fP
.RS 4
ESC + '[' + str 
.RE
.PP

.SS "def ansi\&.CUU ( n)"

.PP
Moves the cursor n (default 1) cells up\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.ED ( n)"

.PP
Clears part of the screen\&. If n is 0 (or missing), clear from cursor to end of screen\&. If n is 1, clear from cursor to beginning of the screen\&. If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI\&.SYS)\&. If n is 3, clear entire screen and delete all lines saved in the scrollback buffer (this feature was added for xterm and is supported by other terminal applications)\&.
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.EL ( n)"

.PP
Erases part of the line If n is 0 (or missing), clear from cursor to the end of the line If n is 1, clear from cursor to beginning of the line If n is 2, clear entire line\&. Cursor position does not change\&.
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.HVP ( row,  col)"

.PP
Same as CUP, but counts as a format effector function (like CR or LF) rather than an editor function (like CUD or CNL) This can lead to different handling in certain terminal modes\&. 
.PP
\fBParameters\fP
.RS 4
\fIrow\fP (int) 
.br
\fIcol\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.RGB ( r,  g,  b)"

.PP
Specify the Foreground color in RGB\&. 
.PP
\fBParameters\fP
.RS 4
\fIr\fP (int) Red value 
.br
\fIg\fP (int) Green value 
.br
\fIb\fP (int) Blue value 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.SD ( n)"

.PP
Scroll whole page down by n (default 1) lines\&. New lines are added at the top\&. (not ANSI\&.SYS)
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.SGR ( str)"

.PP
Sets colors and style of the characters following this code Example: \fBansi\&.SGR\fP('4091') makes RED_HI over BK_BLACK\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP (String) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SS "def ansi\&.SU ( n)"

.PP
Scroll whole page up by n (default 1) lines\&. New lines are added at the bottom\&. (not ANSI\&.SYS)
.PP
\fBParameters\fP
.RS 4
\fIn\fP (int) 
.RE
.PP
\fBReturns\fP
.RS 4
String to be printed 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "string ansi\&.AUX_PORT_OFF = \fBESC\fP+'[4i'"

.PP
Enable aux serial port usually for local serial printer\&. 
.PP
\fBReturns\fP
.RS 4
ESC [4i 
.RE
.PP

.SS "string ansi\&.AUX_PORT_ON = \fBESC\fP+'[5i'"

.PP
Enable aux serial port usually for local serial printer\&. 
.PP
\fBReturns\fP
.RS 4
ESC [5i 
.RE
.PP

.SS "string ansi\&.BK_BLACK = \fBESC\fP+'[40m'"

.SS "string ansi\&.BK_BLACK_HI = \fBESC\fP+'[100m'"

.SS "string ansi\&.BK_BLUE = \fBESC\fP+'[44m'"

.SS "string ansi\&.BK_BLUE_HI = \fBESC\fP+'[104m'"

.SS "string ansi\&.BK_CYAN = \fBESC\fP+'[46m'"

.SS "string ansi\&.BK_CYAN_HI = \fBESC\fP+'[106m'"

.SS "string ansi\&.BK_DEFAULT = \fBESC\fP+'[49m'"

.SS "string ansi\&.BK_GREEN = \fBESC\fP+'[42m'"

.SS "string ansi\&.BK_GREEN_HI = \fBESC\fP+'[102m'"

.SS "string ansi\&.BK_PURPLE = \fBESC\fP+'[45m'"

.SS "string ansi\&.BK_PURPLE_HI = \fBESC\fP+'[105m'"

.SS "string ansi\&.BK_RED = \fBESC\fP+'[41m'"

.SS "string ansi\&.BK_RED_HI = \fBESC\fP+'[101m'"

.SS "string ansi\&.BK_WHITE = \fBESC\fP+'[47m'"

.SS "string ansi\&.BK_WHITE_HI = \fBESC\fP+'[107m'"

.SS "string ansi\&.BK_YELLOW = \fBESC\fP+'[43m'"

.SS "string ansi\&.BK_YELLOW_HI = \fBESC\fP+'[103m'"

.SS "string ansi\&.BLACK = \fBESC\fP+'[30m'"

.SS "string ansi\&.BLACK_HI = \fBESC\fP+'[90m'"

.SS "string ansi\&.BLINK_OFF = \fBESC\fP+'[25m'"

.SS "string ansi\&.BLUE = \fBESC\fP+'[34m'"

.SS "string ansi\&.BLUE_HI = \fBESC\fP+'[94m'"

.SS "string ansi\&.BOLD = \fBESC\fP+'[1m'"

.SS "string ansi\&.BOLD_OFF = \fBESC\fP+'[21m'"

.SS "string ansi\&.C0 = \fBESC\fP+'[11H'"

.PP
Place the cursor in top-left corner Same as CUP(1,1) 
.PP
\fBReturns\fP
.RS 4
ESC [11H 
.RE
.PP

.SS "string ansi\&.CNL1 = \fBESC\fP+'[1E'"

.PP
Moves cursor to beginning of the next line\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1E 
.RE
.PP

.SS "string ansi\&.CPL1 = \fBESC\fP+'[1F'"

.PP
Moves cursor to beginning of the previous line\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1F 
.RE
.PP

.SS "string ansi\&.CSI = '\\u009B'"

.SS "string ansi\&.CUB1 = \fBESC\fP+'[1D'"

.PP
Move the cursor 1 cell backwards\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1D 
.RE
.PP

.SS "string ansi\&.CUD1 = \fBESC\fP+'[1B'"

.PP
Move the cursor 1 row down\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1B 
.RE
.PP

.SS "string ansi\&.CUF1 = \fBESC\fP+'[1C'"

.PP
Move the cursor 1 cell forwards\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1C 
.RE
.PP

.SS "string ansi\&.CUU1 = \fBESC\fP+'[1A'"

.PP
Move the cursor 1 row up\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1A 
.RE
.PP

.SS "string ansi\&.CYAN = \fBESC\fP+'[36m'"

.SS "string ansi\&.CYAN_HI = \fBESC\fP+'[96m'"

.SS "string ansi\&.DEF_FONT = \fBESC\fP+'[10m'"

.PP
Default font\&. 
.SS "string ansi\&.DEFAULT = \fBESC\fP+'[39m'"

.SS "string ansi\&.DSC = '\\u0090'"

.SS "string ansi\&.DSR = \fBESC\fP+'[6n'"

.PP
Reports the cursor position (CPR) by transmitting ESC[nmR, where n is the row and m is the column\&. 
.PP
\fBReturns\fP
.RS 4
ESC [6n 
.RE
.PP

.SS "string ansi\&.ED0 = \fBESC\fP+'[0J'"

.PP
Clear from cursor to end of screen\&. 
.PP
\fBReturns\fP
.RS 4
ESC [0J 
.RE
.PP

.SS "string ansi\&.ED1 = \fBESC\fP+'[1J'"

.PP
Clear from cursor to beginning of the screen\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1J 
.RE
.PP

.SS "string ansi\&.ED2 = \fBESC\fP+'[2J'"

.PP
Clear entire screen (and moves cursor to upper left on DOS ANSI\&.SYS) 
.PP
\fBReturns\fP
.RS 4
ESC [2J 
.RE
.PP

.SS "string ansi\&.ED3 = \fBESC\fP+'[3J'"

.PP
Clear entire screen and delete all lines saved in the scrollback buffer (this feature was added for xterm and is supported by other terminal applications) 
.PP
\fBReturns\fP
.RS 4
ESC [3J 
.RE
.PP

.SS "string ansi\&.EL0 = \fBESC\fP+'[0K'"

.PP
Clear from cursor to the end of the line\&. 
.PP
\fBReturns\fP
.RS 4
ESC [0K 
.RE
.PP

.SS "string ansi\&.EL1 = \fBESC\fP+'[1K'"

.PP
Clear from cursor to beginning of the line\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1K 
.RE
.PP

.SS "string ansi\&.EL2 = \fBESC\fP+'[2K'"

.PP
Clear entire line\&. Cursor position does not change\&.
.PP
\fBReturns\fP
.RS 4
ESC [2K 
.RE
.PP

.SS "string ansi\&.ESC = '\\u001B'"

.SS "string ansi\&.FAINT = \fBESC\fP+'[2m'"

.SS "string ansi\&.Franktur = \fBESC\fP+'[20m'"

.PP
Rarely supported font\&. 
.SS "string ansi\&.GREEN = \fBESC\fP+'[32m'"

.SS "string ansi\&.GREEN_HI = \fBESC\fP+'[92m'"

.SS "string ansi\&.HI_OFF = \fBESC\fP+'[22m'"

.SS "string ansi\&.HIDE = \fBESC\fP+'[8m'"

.SS "string ansi\&.ITALIC = \fBESC\fP+'[3m'"

.SS "string ansi\&.ITALIC_OFF = \fBESC\fP+'[23m'"

.SS "string ansi\&.OSC = '\\u009D'"

.SS "string ansi\&.PURPLE = \fBESC\fP+'[35m'"

.SS "string ansi\&.PURPLE_HI = \fBESC\fP+'[95m'"

.SS "string ansi\&.RBLINK = \fBESC\fP+'[6m'"

.SS "string ansi\&.RCP = \fBESC\fP+'[u'"

.PP
Restores the cursor position/state in SCO console mode\&. 
.PP
\fBReturns\fP
.RS 4
ESC [u 
.RE
.PP

.SS "string ansi\&.RED = \fBESC\fP+'[31m'"

.SS "string ansi\&.RED_HI = \fBESC\fP+'[91m'"

.SS "string ansi\&.RESET = \fBESC\fP+'[0m'"

.SS "string ansi\&.REVEAL = \fBESC\fP+'[28m'"

.SS "string ansi\&.REVERSE = \fBESC\fP+'[7m'"

.SS "string ansi\&.REVERSE_OFF = \fBESC\fP+'[27m'"

.SS "string ansi\&.SBLINK = \fBESC\fP+'[5m'"

.SS "string ansi\&.SCP = \fBESC\fP+'[s'"

.PP
Saves the cursor position/state in SCO console mode In vertical split screen mode, instead used to set (as CSI n n s) or reset left and right margins\&. 
.PP
\fBReturns\fP
.RS 4
ESC [s 
.RE
.PP

.SS "string ansi\&.SD1 = \fBESC\fP+'[1T'"

.PP
Scroll whole page down by 1 line\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1T 
.RE
.PP

.SS "string ansi\&.STRIKE = \fBESC\fP+'[9m'"

.SS "string ansi\&.STRIKE_OFF = \fBESC\fP+'[29m'"

.SS "string ansi\&.SU1 = \fBESC\fP+'[1S'"

.PP
Scroll whole page up by 1 line\&. 
.PP
\fBReturns\fP
.RS 4
ESC [1S 
.RE
.PP

.SS "string ansi\&.UNDER = \fBESC\fP+'[4m'"

.SS "string ansi\&.UNDER_OFF = \fBESC\fP+'[24m'"

.SS "string ansi\&.WHITE = \fBESC\fP+'[37m'"

.SS "string ansi\&.WHITE_HI = \fBESC\fP+'[97m'"

.SS "string ansi\&.YELLOW = \fBESC\fP+'[33m'"

.SS "string ansi\&.YELLOW_HI = \fBESC\fP+'[93m'"

.SH "Author"
.PP 
Generated automatically by Doxygen for ANSI-Project from the source code\&.
